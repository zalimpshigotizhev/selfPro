От хендлера/вью говоря:
Для начало стоит обсудить как подключаются хендлеры:
Это все подключчается через Ninja. Есть один главный Ninja-объект в который впоследствии подключаются router`ы. После этот объект передается в Django urlpatterns.

## intensive_list (handlers.py)
### Хендлер должен компоновать все обработанные данные и передавать в этот самый описанный выше главный объект.
#### Действие:
##### 1) Функция хендлера ожидает два необязательных аргумента. Это фильтры и пагинация. В данном случае эти аргументы может передать клиент. В них уже присутствуют данные по умолчанию, поэтому передавать их вовсе и необязательно.
##### 2) Далее создается объект сервиса. Для дальнейших манипуляций. Напомню, что умеет сервис: Полученные данные из DB он превращает в сущности.
##### 3) Следующим шагом, как раз, мы обращаемся к этому сервису и к его методу get_intensive_list, которому передаем фильтры полученные от клиента и пагинацию соответственно. Что происходит внутри этого метода? Этот метод создает query с использованием Django Q. То есть фильтрует данные по указанным параметрам и ожидает получить их у Django модели при этом превращая их в сущности.
##### 4) Далее мы пользуемся еще одним методом сервиса -get_intensive_count, который получает кол-ство полученных объектов после обработки(фильтрации) данных.
*Тут стоит упоминуть о профите. То есть в данном случае У нас есть сервис который позволяет при запросе возвращать конгурентные данные, если быть точнее, то есть один класс по исключительно одной зоне ответственности (придерживаясь  принципу S в SOLID). Также мы выносим всю бизнесовую логику в отдельную часть.*
##### 5) В этом пункте у нас уже есть сущности данных и их кол-ство из DB. Тут же мы начинаем обработку сущностей для визуализации в виде (гномиков(шутка)) api. В данном процессе нам помогает замечательная библиотека pydantic которая взаимодействует с Ninja. Наша схема IntensiveSchema имеет статический метод from_entity которая принимает сущность и преобразует в схему. Эти данные мы сохраняем в новую переменную items для дальнейшего использование. 
##### 6) Мы также из полученных данных для пагинации формируем схему для пагинации.
##### 7) Заключительный акт: У нас есть ApiResponse который будет в самом конце возвращаться, грубо говоря, это схема которая структурирует в себе все данные которые мы собрали за весь хендлер для получения списка интенсивов (intensive_list)

## Filters (filters.py)
### Тут находится схема IntensiveFilters которую мы используем для queryset в Ninja. В ней одно свойство search. А значит хендлер будет ожидать при надобности queryset для обработки.

## Схемы (schemas.py)
### Тут есть важная схема для этой репозитории IntensiveSchema в ней описываются свойства и их типы которые будут отображаться в конечном API. И тот самый статический метод который образует из сущностей в эту самую схему. Метод упоминается выше.